<?php

use TSantos\Serializer\Exception\InvalidArgumentException;
use TSantos\Serializer\AbstractContext;
use TSantos\Serializer\SerializationContext;
use TSantos\Serializer\DeserializationContext;
use TSantos\Serializer\HydratorInterface;
use TSantos\Serializer\SerializerAwareInterface;
use TSantos\Serializer\Traits\SerializerAwareTrait;
{% for class in hierarchy_classes %}
use {{ class }};
{% endfor %}

/**
 * THIS CLASS WAS GENERATED BY THE SERIALIZER. DO NOT EDIT THIS FILE.
 * @internal
 */
final class {{ class_name }} {{ base_class_name ? 'extends ' ~ base_class_name ~ ' ' }}implements HydratorInterface, SerializerAwareInterface
{
    use SerializerAwareTrait;

    private $exposedGroups = {{ exported_groups|raw }};

{% block class_properties '' %}

{% block constructor '' %}

    /**
     * @param {{ target_class_name }} $object
     * @param SerializationContext $context
     * @return array
     */
    public function extract($object, SerializationContext $context): array
    {
        if (!$object instanceof {{ target_class_name }}) {
            throw new InvalidArgumentException(sprintf('%s is able to serialize only instances of "%s" only. "%s" given', get_class($this), {{ target_class_name }}::class, is_object($object) ? get_class($object) : gettype($object)));
        }

{% if properties|length == 0 and virtual_properties|length == 0 %}
        return [];
{% else %}
        $data = [];
        $shouldSerializeNull = $context->shouldSerializeNull();

{% for prop in properties %}{% if prop.getter %}{% block accessor %}
        // property '{{ prop.name }}'
        if (null !== $value = $object->{{ attribute(prop, 'getter') }}()) {
{% if prop.readValueFilter is not null %}
            $data['{{ prop.exposeAs }}'] = {{ prop.readValueFilter|raw }};
{% elseif prop.type in ['integer', 'string', 'float', 'boolean', 'array'] %}
            $data['{{ prop.exposeAs }}'] = ({{ prop.type }}) $value;
{% else %}
            $data['{{ prop.exposeAs }}'] = $this->serializer->normalize($value, $context);
{% endif %}
        } elseif ($shouldSerializeNull) {
            $data['{{ prop.exposeAs }}'] = null;
        }

{% endblock %}{% else %}{% block reflection_accessor %}
        // property '{{ prop.name }}'
        $propReflection = $this->getReflectionProperty({{ prop.reflection.declaringClass.shortName }}::class, '{{ prop.name }}');
        $propReflection->setAccessible(true);
        if (null !== $value = $propReflection->getValue($object)) {
{% if prop.readValueFilter is not null %}
            $data['{{ prop.exposeAs }}'] = {{ prop.readValueFilter|raw }};
{% elseif prop.type in ['integer', 'string', 'float', 'boolean', 'array'] %}
            $data['{{ prop.exposeAs }}'] = ({{ prop.type }}) $value;
{% else %}
            $data['{{ prop.exposeAs }}'] = $this->serializer->normalize($value, $context);
{% endif %}
        } elseif ($shouldSerializeNull) {
            $data['{{ prop.exposeAs }}'] = null;
        }

{% endblock %}{% endif %}
{% endfor %}
{% for prop in virtual_properties %}{% block virtual_property %}
        // property '{{ prop.name }}'
        if (null !== $value = $object->{{ prop.name }}()) {
{% if prop.readValueFilter is not null %}
            $data['{{ prop.exposeAs }}'] = {{ prop.readValueFilter|raw }};
{% elseif prop.type in ['integer', 'string', 'float', 'boolean'] %}
            $data['{{ prop.exposeAs }}'] = ({{ prop.type }}) $value;
{% else %}
            $data['{{ prop.exposeAs }}'] = $this->serializer->normalize($value, $context);
{% endif %}
        } elseif ($shouldSerializeNull) {
            $data['{{ prop.exposeAs }}'] = null;
        }
{% endblock %}

{% endfor %}
        static $contextKeys = [];
        $contextId = spl_object_hash($context);

        if (!isset($contextKeys[$contextId])) {
            $contextKeys[$contextId] = $this->getExposedKeys($context);
        }

        $data = array_intersect_key($data, $contextKeys[$contextId]);

        return $data;
{% endif %}
    }

    /**
     * @param {{ target_class_name }} $object
     * @param array $data
     * @param DeserializationContext $context
     * @return {{ target_class_name }}
     */
    public function hydrate($object, array $data, DeserializationContext $context)
    {
        if (!$object instanceof {{ target_class_name }}) {
            throw new InvalidArgumentException(sprintf('%s is able to deserialize only instances of "%s" only. "%s" given', get_class($this), {{ target_class_name }}::class, is_object($object) ? get_class($object) : gettype($object)));
        }
{% if properties|length > 0 %}

        static $contextKeys = [];
        $contextId = spl_object_hash($context);

        if (!isset($contextKeys[$contextId])) {
            $contextKeys[$contextId] = $this->getExposedKeys($context);
        }

        $data = array_intersect_key($data, $contextKeys[$contextId]);

{% for prop in properties if not prop.readOnly%}{% if prop.setter %}{% block mutator %}
        // property '{{ prop.name }}'
        if (isset($data['{{ prop.exposeAs }}'])) {
            if (null !== $value = $data['{{ prop.exposeAs }}']) {
{% if prop.writeValueFilter is not null %}
            $object->{{ prop.setter }}({{ prop.writeValueFilter|raw }});
{% elseif prop.type in ['integer', 'string', 'float', 'boolean', 'array'] %}
            $object->{{ prop.setter }}(({{ prop.type }}) $value);
{% else %}
            $object->{{ prop.setter }}($this->serializer->denormalize($value, '{{ prop.type|raw }}', $context));
{% endif %}
            } else {
                $object->{{ prop.setter }}(null);
            }
        }
{% endblock %}{% else %}{% block reflection_mutator %}
        // property '{{ prop.name }}'
        if (isset($data['{{ prop.exposeAs }}'])) {
            $propReflection = $this->getReflectionProperty({{ prop.reflection.declaringClass.shortName }}::class, '{{ prop.name }}');
            $propReflection->setAccessible(true);
            if (null !== $value = $data['{{ prop.exposeAs }}']) {
    {% if prop.writeValueFilter is not null %}
            $propReflection->setValue($object, {{ prop.writeValueFilter|raw }});
    {% elseif prop.type in ['integer', 'string', 'float', 'boolean', 'array'] %}
            $propReflection->setValue($object, $value);
    {% else %}
            $propReflection->setValue($object, $this->serializer->denormalize($value, '{{ prop.type|raw }}', $context));
    {% endif %}
        } else {
                $propReflection->setValue($object, null);
            }
        }
{% endblock %}{% endif %}

{% endfor %}
        return $object;
{% endif %}
    }

    private function getExposedKeys(AbstractContext $context)
    {
        $contextGroups = $context->getGroups();
        $exposedGroups = array_intersect_key($this->exposedGroups, $contextGroups);
        $exposedKeys = array_reduce($exposedGroups, function ($keys, $groupKeys) {
            array_push($keys, ...(array_keys($groupKeys)));
            return $keys;
        }, []);

        return array_flip($exposedKeys);
    }

    private function getReflectionProperty(string $class, string $property): \ReflectionProperty
    {
        static $reflections;

        if (null === $reflections) {
            $reflections = [
    {% for class in hierarchy_classes %}
            '{{ class }}' => new \ReflectionClass('{{ class }}'),
    {% endfor %}
        ];
        }

        return $reflections[$class]->getProperty($property);
    }
}

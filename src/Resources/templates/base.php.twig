<?php

use TSantos\Serializer\Exception\InvalidArgumentException;
use TSantos\Serializer\AbstractContext;
use TSantos\Serializer\SerializationContext;
use TSantos\Serializer\DeserializationContext;
{% for class in hierarchy_classes %}
use {{ class }};
{% endfor %}

/**
 * THIS CLASS WAS GENERATED BY THE SERIALIZER. DO NOT EDIT THIS FILE.
 * @internal
 */
final class {{ class_name }} extends {{ base_class_name }}
{
    private $exposedGroups = {{ exported_groups|raw }};

    /**
     * @param {{ target_class_name }} $object
     * @param SerializationContext $context
     * @return array
     */
    public function serialize($object, SerializationContext $context): array
    {
        if (!$object instanceof {{ target_class_name }}) {
            throw new InvalidArgumentException(sprintf('%s is able to serialize only instances of "%s" only. "%s" given', get_class($this), {{ target_class_name }}::class, is_object($object) ? get_class($object) : gettype($object)));
        }

{% if properties|length == 0 and virtual_properties|length == 0 %}
        return [];
{% else %}
        $data = [];
        $exposedKeys = $this->getExposedKeys($context);
        $shouldSerializeNull = $context->shouldSerializeNull();
{% block serializer_initialization '' %}

{% for prop in properties if prop.getter is defined %}{% block property_getters '' %}{% endfor %}
{% for prop in virtual_properties %}{% block virtual_property_getters '' %}{% endfor %}
        return $data;
{% endif %}
    }

    /**
     * @param {{ target_class_name }} $object
     * @param array $data
     * @param DeserializationContext $context
     * @return {{ target_class_name }}
     */
    public function deserialize($object, array $data, DeserializationContext $context)
    {
        if (!$object instanceof {{ target_class_name }}) {
            throw new InvalidArgumentException(sprintf('%s is able to deserialize only instances of "%s" only. "%s" given', get_class($this), Person::class, is_object($object) ? get_class($object) : gettype($object)));
        }
{% if properties|length > 0 %}

        $exposedKeys = $this->getExposedKeys($context);
{% block deserializer_initialization '' %}

{% for prop in properties if prop.setter and not prop.readOnly%}
{% block property_setters '' %}
{% endfor %}
        return $object;
{% endif %}
    }

    /**
     * @param AbstractContext $context
     * @return array
     */
    final private function getExposedKeys(AbstractContext $context)
    {
        if ($this->computedGroupKeys->contains($context)) {
            return $this->computedGroupKeys[$context];
        }

        $contextGroups = array_flip($context->getGroups());

        $computedKeys = array_flip(array_reduce(array_intersect_key($this->exposedGroups, $contextGroups), function ($g, $v) {
            array_push($g, ...$v);
            return $g;
        }, []));

        $this->computedGroupKeys->attach($context, $computedKeys);

        return $computedKeys;
    }
{% block additional_methods '' %}
}

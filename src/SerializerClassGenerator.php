<?php

namespace TSantos\Serializer;

use Metadata\ClassMetadata;

/**
 * Class ObjectSerializerGenerator
 *
 * @package Serializer
 * @author Tales Santos <tales.augusto.santos@gmail.com>
 */
class SerializerClassGenerator
{
    /**
     * @var string
     */
    private $path;

    /**
     * @var TypeRegistryInterface
     */
    private $typeRegistry;

    /**
     * @var bool
     */
    private $debug;

    /**
     * @var array
     */
    private $instances = [];

    /**
     * SerializerClassGenerator constructor.
     * @param string $path
     * @param TypeRegistryInterface $typeRegistry
     * @param bool $debug
     */
    public function __construct(string $path, TypeRegistryInterface $typeRegistry, bool $debug = false)
    {
        $this->path = $path;
        $this->typeRegistry = $typeRegistry;
        $this->debug = $debug;
    }

    /**
     * @param ClassMetadata $classMetadata
     * @param Serializer $serializer
     * @return SerializerClassInterface
     */
    public function getGeneratorFor(ClassMetadata $classMetadata, Serializer $serializer): SerializerClassInterface
    {
        $fqn = $this->getClassName($classMetadata);

        if (isset($this->instances[$fqn])) {
            return $this->instances[$fqn];
        }

        if (class_exists($fqn, false)) {
            return $this->instances[$fqn] = new $fqn($serializer, $classMetadata);
        }

        $filename = $this->getFilename($classMetadata);

        if (!$this->debug && file_exists($filename)) {
            require_once $filename;
            return $this->instances[$fqn] = new $fqn($serializer, $classMetadata);
        }

        $code = $this->classDeclaration($classMetadata, $fqn);

        file_put_contents($filename, $code);
        chmod($filename, 0664);

        require $filename;

        return $this->instances[$fqn] = new $fqn($serializer, $classMetadata);
    }

    private function getClassName(ClassMetadata $metadata): string
    {
        return str_replace('\\', '', $metadata->name) . 'Serializer';
    }

    private function getFilename(ClassMetadata $metadata): string
    {
        return $this->path . DIRECTORY_SEPARATOR . $this->getClassName($metadata) . '.php';
    }

    private function classDeclaration(ClassMetadata $metadata, string $className): string
    {
        return <<<EOF
<?php

use TSantos\Serializer\AbstractSerializerClass;
use TSantos\Serializer\Exception\InvalidArgumentException;
use TSantos\Serializer\SerializationContext;

/**
 * THIS CLASS WAS GENERATED BY THE SERIALIZER. DO NOT EDIT THIS FILE.
 */
class $className extends AbstractSerializerClass
{
{$this->serializeMethod($metadata)}
}

EOF;
    }

    private function serializeMethod(ClassMetadata $metadata): string
    {
        return <<<EOF
    /**
     * @param {$metadata->name} \$object
     * @param SerializationContext \$context
     * @return array
     */
    public function serialize(\$object, SerializationContext \$context): array
    {
{$this->serializeMethodBody($metadata)}
    }
EOF;
    }

    private function serializeMethodBody(ClassMetadata $metadata): string
    {
        $code = <<<EOF
        if (!\$object instanceof {$metadata->name}) {
            throw new InvalidArgumentException(sprintf('%s can serialize instances of "%s" only. "%s" given', get_class(\$this), '{$metadata->name}', is_object(\$object) ? get_class(\$object) : gettype(\$object)));
        }

        \$data = [];
        \$shouldSerializeNull = \$context->shouldSerializeNull();

EOF;
        $code .=
            $this->properties($metadata) .
            $this->virtualProperties($metadata);

        $code .= <<<EOF
        
        return \$data;
EOF;

        return $code;
    }

    private function properties(ClassMetadata $metadata): string
    {
        $code = '';

        foreach ($metadata->propertyMetadata as $property) {
            $getter = "\$object->{$property->getter}()";
            $value = '$value';

            $code .= <<<EOF
        #property '$property->name'
        if (\$this->isPropertyGroupExposed('{$property->name}', \$context)) {
            if (null !== \$value = $getter) {
                {$this->renderValue($property, $value)}
            } elseif (\$shouldSerializeNull) {
                \$data['$property->exposeAs'] = null;
            }
        }

EOF;
        }

        return $code;
    }

    private function virtualProperties(ClassMetadata $metadata): string
    {
        $code = '';

        foreach ($metadata->methodMetadata as $property) {
            $getter = "\$object->{$property->name}()";
            $value = '$value';

            $code .= <<<EOF
        #virtual property '$property->name'
        if (\$this->isVirtualPropertyGroupExposed('{$property->name}', \$context)) {
            if (null !== \$value = $getter) {
                {$this->renderValue($property, $value)}
            } elseif (\$shouldSerializeNull) {
                \$data['$property->exposeAs'] = null;
            }
        }

EOF;

        }

        return $code;
    }

    private function renderValue($property, string $value)
    {
        if ($this->isScalarType($property->type)) {
            return <<<EOF
\$data['$property->exposeAs'] = {$this->castType($value, $property->type)};
EOF;
        } else {
            return <<<EOF
\$data['$property->exposeAs'] = \$this->serializer->toArray($value, \$context);
EOF;
        }
    }

    private function castType(string $value, string $type)
    {
        return sprintf('(%s) %s', $type, $value);
    }

    private function isScalarType(string $type)
    {
        return in_array($type, ['integer', 'string', 'float', 'boolean']);
    }
}

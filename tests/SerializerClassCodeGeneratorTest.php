<?php
/**
 * This file is part of the TSantos Serializer package.
 *
 * (c) Tales Santos <tales.augusto.santos@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Tests\TSantos\Serializer;

use PHPUnit\Framework\TestCase;
use Tests\TSantos\Serializer\Fixture\Model\Person;
use TSantos\Serializer\Metadata\ClassMetadata;
use TSantos\Serializer\Metadata\PropertyMetadata;
use TSantos\Serializer\Metadata\VirtualPropertyMetadata;
use TSantos\Serializer\SerializerClassCodeGenerator;

/**
 * Class SerializerClassCodeGeneratorTest
 *
 * @author Tales Santos <tales.augusto.santos@gmail.com>
 */
class SerializerClassCodeGeneratorTest extends TestCase
{
    private $twig;

    public function setUp()
    {
        $loader = new \Twig_Loader_Filesystem([__DIR__ . '/../src/Resources/templates']);

        $this->twig = new \Twig_Environment($loader, [
            'debug' => true,
            'strict_variables' => true
        ]);
    }

    /** @test */
    public function it_can_generate_class_using_accessors()
    {
        $generator = new SerializerClassCodeGenerator($this->twig, 'accessors.php.twig');
        $metadata = $this->createMetadata();
        $code = $generator->generate($metadata);
        $expected = <<<'CODE'
<?php

use TSantos\Serializer\Exception\InvalidArgumentException;
use TSantos\Serializer\AbstractContext;
use TSantos\Serializer\SerializationContext;
use TSantos\Serializer\DeserializationContext;
use Tests\TSantos\Serializer\Fixture\Model\Person;

/**
 * THIS CLASS WAS GENERATED BY THE SERIALIZER. DO NOT EDIT THIS FILE.
 * @internal
 */
final class TestsTSantosSerializerFixtureModelPersonSerializer extends TSantos\Serializer\AbstractSerializerClass
{
    private $exposedGroups = array (
  'Default' => 
  array (
    'id' => true,
    'birthday' => true,
    'father' => true,
    'full_name' => true,
  ),
);

    /**
     * @param Person $object
     * @param SerializationContext $context
     * @return array
     */
    public function serialize($object, SerializationContext $context): array
    {
        if (!$object instanceof Person) {
            throw new InvalidArgumentException(sprintf('%s is able to serialize only instances of "%s" only. "%s" given', get_class($this), Person::class, is_object($object) ? get_class($object) : gettype($object)));
        }

        $data = [];
        $shouldSerializeNull = $context->shouldSerializeNull();

        // property 'id'
        if (null !== $value = $object->getId()) {
            $data['id'] = (integer) $value;
        } elseif ($shouldSerializeNull) {
            $data['id'] = null;
        }

        // property 'birthday'
        if (null !== $value = $object->getBirthday()) {
            $data['birthday'] = $value->format("d/m/Y");
        } elseif ($shouldSerializeNull) {
            $data['birthday'] = null;
        }

        // property 'father'
        if (null !== $value = $object->getFather()) {
            $data['father'] = $this->serializer->normalize($value, $context);
        } elseif ($shouldSerializeNull) {
            $data['father'] = null;
        }

        // property 'getFullName'
        if (null !== $value = $object->getFullName()) {
            $data['full_name'] = (string) $value;
        } elseif ($shouldSerializeNull) {
            $data['full_name'] = null;
        }

        static $contextKeys = [];
        $contextId = spl_object_hash($context);

        if (!isset($contextKeys[$contextId])) {
            $contextKeys[$contextId] = $this->getExposedKeys($context);
        }

        $data = array_intersect_key($data, $contextKeys[$contextId]);

        return $data;
    }

    /**
     * @param Person $object
     * @param array $data
     * @param DeserializationContext $context
     * @return Person
     */
    public function deserialize($object, array $data, DeserializationContext $context)
    {
        if (!$object instanceof Person) {
            throw new InvalidArgumentException(sprintf('%s is able to deserialize only instances of "%s" only. "%s" given', get_class($this), Person::class, is_object($object) ? get_class($object) : gettype($object)));
        }

        static $contextKeys = [];
        $contextId = spl_object_hash($context);

        if (!isset($contextKeys[$contextId])) {
            $contextKeys[$contextId] = $this->getExposedKeys($context);
        }

        $data = array_intersect_key($data, $contextKeys[$contextId]);

        // property 'birthday'
        if (isset($data['birthday'])) {
            if (null !== $value = $data['birthday']) {
                $object->setBirthday($this->serializer->denormalize($value, 'DateTime', $context));
            } else {
                $object->setBirthday(null);
            }
        }

        // property 'father'
        if (isset($data['father'])) {
            if (null !== $value = $data['father']) {
                $object->setFather($this->serializer->denormalize($value, 'Tests\TSantos\Serializer\Fixture\Model\Person', $context));
            } else {
                $object->setFather(null);
            }
        }

        return $object;
    }

    /**
     * @param AbstractContext $context
     * @return array
     */
    final private function getExposedKeys(AbstractContext $context)
    {
        $contextGroups = $context->getGroups();
        $exposedGroups = array_intersect_key($this->exposedGroups, $contextGroups);
        $exposedKeys = array_reduce($exposedGroups, function ($keys, $groupKeys) {
            array_push($keys, ...(array_keys($groupKeys)));
            return $keys;
        }, []);

        return array_flip($exposedKeys);
    }
}

CODE;
        $this->assertEquals($expected, $code);
    }

    /** @test */
    public function it_can_generate_class_using_reflection()
    {
        $generator = new SerializerClassCodeGenerator($this->twig, 'reflection.php.twig');
        $metadata = $this->createMetadata();
        $code = $generator->generate($metadata);
        $expected = <<<'CODE'
<?php

use TSantos\Serializer\Exception\InvalidArgumentException;
use TSantos\Serializer\AbstractContext;
use TSantos\Serializer\SerializationContext;
use TSantos\Serializer\DeserializationContext;
use Tests\TSantos\Serializer\Fixture\Model\Person;

/**
 * THIS CLASS WAS GENERATED BY THE SERIALIZER. DO NOT EDIT THIS FILE.
 * @internal
 */
final class TestsTSantosSerializerFixtureModelPersonSerializer extends TSantos\Serializer\AbstractSerializerClass
{
    private $exposedGroups = array (
  'Default' => 
  array (
    'id' => true,
    'birthday' => true,
    'father' => true,
    'full_name' => true,
  ),
);

    /**
     * @param Person $object
     * @param SerializationContext $context
     * @return array
     */
    public function serialize($object, SerializationContext $context): array
    {
        if (!$object instanceof Person) {
            throw new InvalidArgumentException(sprintf('%s is able to serialize only instances of "%s" only. "%s" given', get_class($this), Person::class, is_object($object) ? get_class($object) : gettype($object)));
        }

        $data = [];
        $shouldSerializeNull = $context->shouldSerializeNull();

        // property 'id'
        $propReflection = static::getReflection(Person::class, 'id');
        $public = $propReflection->isPublic();
        if (!$public) {
            $propReflection->setAccessible(true);
        }
        if (null !== $value = $propReflection->getValue($object)) {
            $data['id'] = (integer) $value;
        } elseif ($shouldSerializeNull) {
            $data['id'] = null;
        }
        if (!$public) {
            $propReflection->setAccessible(false);
        }

        // property 'birthday'
        $propReflection = static::getReflection(Person::class, 'birthday');
        $public = $propReflection->isPublic();
        if (!$public) {
            $propReflection->setAccessible(true);
        }
        if (null !== $value = $propReflection->getValue($object)) {
            $data['birthday'] = $value->format("d/m/Y");
        } elseif ($shouldSerializeNull) {
            $data['birthday'] = null;
        }
        if (!$public) {
            $propReflection->setAccessible(false);
        }

        // property 'father'
        $propReflection = static::getReflection(Person::class, 'father');
        $public = $propReflection->isPublic();
        if (!$public) {
            $propReflection->setAccessible(true);
        }
        if (null !== $value = $propReflection->getValue($object)) {
            $data['father'] = $this->serializer->normalize($value, $context);
        } elseif ($shouldSerializeNull) {
            $data['father'] = null;
        }
        if (!$public) {
            $propReflection->setAccessible(false);
        }

        // property 'getFullName'
        if (null !== $value = $object->getFullName()) {
            $data['full_name'] = (string) $value;
        } elseif ($shouldSerializeNull) {
            $data['full_name'] = null;
        }

        static $contextKeys = [];
        $contextId = spl_object_hash($context);

        if (!isset($contextKeys[$contextId])) {
            $contextKeys[$contextId] = $this->getExposedKeys($context);
        }

        $data = array_intersect_key($data, $contextKeys[$contextId]);

        return $data;
    }

    /**
     * @param Person $object
     * @param array $data
     * @param DeserializationContext $context
     * @return Person
     */
    public function deserialize($object, array $data, DeserializationContext $context)
    {
        if (!$object instanceof Person) {
            throw new InvalidArgumentException(sprintf('%s is able to deserialize only instances of "%s" only. "%s" given', get_class($this), Person::class, is_object($object) ? get_class($object) : gettype($object)));
        }

        static $contextKeys = [];
        $contextId = spl_object_hash($context);

        if (!isset($contextKeys[$contextId])) {
            $contextKeys[$contextId] = $this->getExposedKeys($context);
        }

        $data = array_intersect_key($data, $contextKeys[$contextId]);

        // property 'birthday'
        if (isset($data['birthday'])) {
            $propReflection = self::getReflection(Person::class, 'birthday');
            $public = $propReflection->isPublic();
            if (!$public) {
                $propReflection->setAccessible(true);
            }
            if (null !== $value = $data['birthday']) {
                $propReflection->setValue($object, $this->serializer->denormalize($value, 'DateTime', $context));
            } else {
                $object->setBirthday(null);
            }
            if (!$public) {
                $propReflection->setAccessible(false);
            }
        }

        // property 'father'
        if (isset($data['father'])) {
            $propReflection = self::getReflection(Person::class, 'father');
            $public = $propReflection->isPublic();
            if (!$public) {
                $propReflection->setAccessible(true);
            }
            if (null !== $value = $data['father']) {
                $propReflection->setValue($object, $this->serializer->denormalize($value, 'Tests\TSantos\Serializer\Fixture\Model\Person', $context));
            } else {
                $object->setFather(null);
            }
            if (!$public) {
                $propReflection->setAccessible(false);
            }
        }

        return $object;
    }

    /**
     * @param AbstractContext $context
     * @return array
     */
    final private function getExposedKeys(AbstractContext $context)
    {
        $contextGroups = $context->getGroups();
        $exposedGroups = array_intersect_key($this->exposedGroups, $contextGroups);
        $exposedKeys = array_reduce($exposedGroups, function ($keys, $groupKeys) {
            array_push($keys, ...(array_keys($groupKeys)));
            return $keys;
        }, []);

        return array_flip($exposedKeys);
    }

    private function getReflection(string $class, string $property): \ReflectionProperty
    {
        static $reflections;

        if (null === $reflections) {
            $reflections = [
                'Tests\TSantos\Serializer\Fixture\Model\Person' => new \ReflectionClass('Tests\TSantos\Serializer\Fixture\Model\Person'),
            ];
        }

        return $reflections[$class]->getProperty($property);
    }
}

CODE;
        $this->assertEquals($expected, $code);
    }

    private function createMetadata(): ClassMetadata
    {
        $metadata = new ClassMetadata(Person::class);

        $id = new PropertyMetadata(Person::class, 'id');
        $id->type = 'integer';
        $id->setGetter('getId');
        $metadata->addPropertyMetadata($id);

        $birthday = new PropertyMetadata(Person::class, 'birthday');
        $birthday->type = 'DateTime';
        $birthday->readValue = '$value->format("d/m/Y")';
        $birthday->setGetter('getBirthday');
        $birthday->setSetter('setBirthday');
        $metadata->addPropertyMetadata($birthday);

        $father = new PropertyMetadata(Person::class, 'father');
        $father->type = Person::class;
        $father->setGetter('getFather');
        $father->setSetter('setFather');
        $metadata->addPropertyMetadata($father);

        $fullName = new VirtualPropertyMetadata(Person::class, 'getFullName');
        $fullName->exposeAs = 'full_name';
        $metadata->addMethodMetadata($fullName);

        return $metadata;
    }

}

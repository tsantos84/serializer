<?php

declare(strict_types=1);
/**
 * This file is part of the TSantos Serializer package.
 *
 * (c) Tales Santos <tales.augusto.santos@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Tests\TSantos\Serializer;

use PHPUnit\Framework\TestCase;
use Tests\TSantos\Serializer\Fixture\Model\Dummy;
use TSantos\Serializer\HydratorCodeGenerator;
use TSantos\Serializer\Metadata\ClassMetadata;
use TSantos\Serializer\Metadata\PropertyMetadata;
use TSantos\Serializer\Metadata\VirtualPropertyMetadata;

/**
 * Class CodeGeneratorTest.
 *
 * @author Tales Santos <tales.augusto.santos@gmail.com>
 */
class CodeGeneratorTest extends TestCase
{
    private $twig;

    public function setUp()
    {
        $loader = new \Twig_Loader_Filesystem([__DIR__.'/../src/Resources/templates']);

        $this->twig = new \Twig_Environment($loader, [
            'debug' => true,
            'strict_variables' => true,
        ]);
    }

    /** @test */
    public function it_can_generate_class_code()
    {
        $generator = new HydratorCodeGenerator($this->twig);
        $metadata = $this->createMetadata();
        $code = $generator->generate($metadata);
        $expected = <<<'CODE'
<?php

use TSantos\Serializer\Exception\InvalidArgumentException;
use TSantos\Serializer\AbstractContext;
use TSantos\Serializer\SerializationContext;
use TSantos\Serializer\DeserializationContext;
use TSantos\Serializer\HydratorInterface;
use TSantos\Serializer\SerializerAwareInterface;
use TSantos\Serializer\Traits\SerializerAwareTrait;
use Tests\TSantos\Serializer\Fixture\Model\Dummy;

/**
 * THIS CLASS WAS GENERATED BY THE SERIALIZER. DO NOT EDIT THIS FILE.
 * @internal
 */
final class TestsTSantosSerializerFixtureModelDummyHydrator extends \stdClass implements HydratorInterface, SerializerAwareInterface
{
    use SerializerAwareTrait;

    private $exposedGroups = array (
  'Default' => 
  array (
    'foo' => true,
    'bar' => true,
    'innerDummy' => true,
    'foobar' => true,
  ),
);

    /**
     * @param Dummy $object
     * @param SerializationContext $context
     * @return array
     */
    public function extract($object, SerializationContext $context): array
    {
        if (!$object instanceof Dummy) {
            throw new InvalidArgumentException(sprintf('%s is able to serialize only instances of "%s" only. "%s" given', get_class($this), Dummy::class, is_object($object) ? get_class($object) : gettype($object)));
        }

        $data = [];
        $shouldSerializeNull = $context->shouldSerializeNull();

        // property 'foo'
        if (null !== $value = $object->getFoo()) {
            $data['foo'] = (string) $value;
        } elseif ($shouldSerializeNull) {
            $data['foo'] = null;
        }

        // property 'bar'
        if (null !== $value = $object->getBar()) {
            $data['bar'] = strtoupper($value);
        } elseif ($shouldSerializeNull) {
            $data['bar'] = null;
        }

        // property 'innerDummy'
        $propReflection = $this->getReflectionProperty(Dummy::class, 'innerDummy');
        $propReflection->setAccessible(true);
        if (null !== $value = $propReflection->getValue($object)) {
            $data['innerDummy'] = $this->serializer->normalize($value, $context);
        } elseif ($shouldSerializeNull) {
            $data['innerDummy'] = null;
        }

        // property 'getFooBar'
        if (null !== $value = $object->getFooBar()) {
            $data['foobar'] = (string) $value;
        } elseif ($shouldSerializeNull) {
            $data['foobar'] = null;
        }

        static $contextKeys = [];
        $contextId = spl_object_hash($context);

        if (!isset($contextKeys[$contextId])) {
            $contextKeys[$contextId] = $this->getExposedKeys($context);
        }

        $data = array_intersect_key($data, $contextKeys[$contextId]);

        return $data;
    }

    /**
     * @param Dummy $object
     * @param array $data
     * @param DeserializationContext $context
     * @return Dummy
     */
    public function hydrate($object, array $data, DeserializationContext $context)
    {
        if (!$object instanceof Dummy) {
            throw new InvalidArgumentException(sprintf('%s is able to deserialize only instances of "%s" only. "%s" given', get_class($this), Dummy::class, is_object($object) ? get_class($object) : gettype($object)));
        }

        static $contextKeys = [];
        $contextId = spl_object_hash($context);

        if (!isset($contextKeys[$contextId])) {
            $contextKeys[$contextId] = $this->getExposedKeys($context);
        }

        $data = array_intersect_key($data, $contextKeys[$contextId]);

        // property 'foo'
        if (isset($data['foo'])) {
            $propReflection = $this->getReflectionProperty(Dummy::class, 'foo');
            $propReflection->setAccessible(true);
            if (null !== $value = $data['foo']) {
                $propReflection->setValue($object, $value);
            } else {
                $propReflection->setValue($object, null);
            }
        }

        // property 'bar'
        if (isset($data['bar'])) {
            if (null !== $value = $data['bar']) {
            $object->setBar((string) $value);
            } else {
                $object->setBar(null);
            }
        }

        // property 'innerDummy'
        if (isset($data['innerDummy'])) {
            $propReflection = $this->getReflectionProperty(Dummy::class, 'innerDummy');
            $propReflection->setAccessible(true);
            if (null !== $value = $data['innerDummy']) {
                $propReflection->setValue($object, $this->serializer->denormalize($value, 'Tests\TSantos\Serializer\Fixture\Model\Dummy', $context));
            } else {
                $propReflection->setValue($object, null);
            }
        }

        return $object;
    }

    private function getExposedKeys(AbstractContext $context)
    {
        $contextGroups = $context->getGroups();
        $exposedGroups = array_intersect_key($this->exposedGroups, $contextGroups);
        $exposedKeys = array_reduce($exposedGroups, function ($keys, $groupKeys) {
            array_push($keys, ...(array_keys($groupKeys)));
            return $keys;
        }, []);

        return array_flip($exposedKeys);
    }

    private function getReflectionProperty(string $class, string $property): \ReflectionProperty
    {
        static $reflections;

        if (null === $reflections) {
            $reflections = [
                'Tests\TSantos\Serializer\Fixture\Model\Dummy' => new \ReflectionClass('Tests\TSantos\Serializer\Fixture\Model\Dummy'),
            ];
        }

        return $reflections[$class]->getProperty($property);
    }
}

CODE;
        $this->assertEquals($expected, $code);
    }

    private function createMetadata(): ClassMetadata
    {
        $metadata = new ClassMetadata(Dummy::class);
        $metadata->baseClass = '\stdClass';
        $metadata->template = 'hydrator.php.twig';

        $foo = new PropertyMetadata(Dummy::class, 'foo');
        $foo->type = 'string';
        $foo->setGetter('getFoo');
        $metadata->addPropertyMetadata($foo);

        $bar = new PropertyMetadata(Dummy::class, 'bar');
        $bar->type = 'string';
        $bar->readValueFilter = 'strtoupper($value)';
        $bar->setGetter('getBar');
        $bar->setSetter('setBar');
        $metadata->addPropertyMetadata($bar);

        $innerDummy = new PropertyMetadata(Dummy::class, 'innerDummy');
        $innerDummy->type = Dummy::class;
        $metadata->addPropertyMetadata($innerDummy);

        $fooBar = new VirtualPropertyMetadata(Dummy::class, 'getFooBar');
        $fooBar->type = 'string';
        $fooBar->exposeAs = 'foobar';
        $metadata->addMethodMetadata($fooBar);

        return $metadata;
    }
}

Usage
=====

The Serializer instance
-----------------------

Creating a new instance of `TSantos\\Serializer\\SerializerInterface` is a complex work because it has a couple of
dependencies and instantiate all of them manually can be hard. Thanks to `TSantos\\Serializer\\SerializerBuilder`
you can quickly create a instance of `SerializerInterface` and start transforming your data without much effort::

    $builder = new SerializerBuilder();

    $serializer = $builder
      ->addMetadataDir('App\Entity', '/project/src/Entity')
      ->build();

    $post = new App\Entity\Post(100, 'Post Title');

    echo $serializer->serialize($post); // {"id":100, "name":"Post Title"}

Basic Mapping
-------------

Telling to serializer how it should transform your data is a very important step to assert that the transformation will
not serialize the data with a wrong data type. Let's see how the `Post` class of previous example could be mapped:

.. code-block:: php-annotations

    namespace App\Entity;

    use TSantos\Serializer\Mapping as Serializer;

    class Post
    {
        /**
         * @Serializer\Type("integer")
         */
        public $id;

        /**
         * @Serializer\Type("string")
         */
        public $title;

        // ...
    }

.. code-block:: yaml

    App\Entity\Post:
        properties:
            id:
                type: integer
            title:
                type: string

.. code-block:: xml

    <?xml version="1.0" encoding="utf-8" ?>
    <serializer>
        <class name="App\Entity\Post">
            <property name="id" type="integer" />
            <property name="title" type="string" />
        </class>
    </serializer>

.. note::
    There is no difference in terms of performance between the mapping formats. In fact, the metadata generated by the
    mapping will be cached and reused in the next serialization operation, so you can choose the most comfortable format
    for you.

Because the builder accepts many metadata directories, you can mix the formats in the same serializer instance::

    $builder = new SerializerBuilder();

    $serializer = $builder
      ->addMetadataDir('App\Document', '/project/config/serializer') // yaml metadata files
      ->addMetadataDir('App\Entity', '/project/src/Entity') // annotation metadata files
      ->build();

By giving a non-empty namespace prefix in the `addMetadataDir` call, the serialize will omit that prefix and will look
for mapping files with the remaining namespace. For example, given the previous PHP snippet and you have the
`App\\Document\\Author` class, then you should have a corresponding mapping file called `Author.yaml` in the
`/project/config/serializer` directory.

Therefore, if you prefix the namespace only with `App`, then the serializer will
look for a file named `Document.Author.yaml`.
